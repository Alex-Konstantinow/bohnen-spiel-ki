package ai;

public class GameState {

    /**
     * Saves a possible game state generated by a turn.
     * Is needed to implement the game tree.
     */
    private BeanCell[] cells = new BeanCell[12];
    private int heuristic;
    private int depthInTree;

    public GameState(BeanCell[] gamestate){
        for(int i = 0; i < gamestate.length; i++){
            cells[i] = new BeanCell(gamestate[i].getIndex(), gamestate[i].getBeans());
            cells[i].setNextCell(gamestate[i].getNextCell());
            cells[i].setPreviousCell(gamestate[i].getPreviousCell());
        }
        this.heuristic = calculateHeuristic();
    }

    /**
     * Changing the game state after the enemys move and builds the new game tree.
     * @param enemyIndex is the index of the chosen cell the enemy emptied
     */
    public void changeCurrentGamestate(int enemyIndex) {
        int chosenIndex = --enemyIndex;
        int numberOfBeans = cells[chosenIndex].getBeans();
        cells[chosenIndex].emptyCell();
        cells[chosenIndex].distributeBeans(numberOfBeans);
    }

    public BeanCell[] getCells() {
        return cells;
    }

    public void setCells(BeanCell[] cells) {
        this.cells = cells;
    }

    public int getHeuristic() {
        return heuristic;
    }

    public void setHeuristic(int heuristic) {
        this.heuristic = heuristic;
    }

    public int getDepthInTree() {
        return depthInTree;
    }

    public void setDepthInTree(int depthInTree) {
        this.depthInTree = depthInTree;
    }

    /**
     * TODO: Implement the heuristic calculation.
     * @return calculated heuristic for the game state
     */
    private int calculateHeuristic(){
        int calculatedHeuristic = 0;
        return calculatedHeuristic;
    }
}
