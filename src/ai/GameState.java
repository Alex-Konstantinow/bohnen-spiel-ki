package ai;

public class GameState {

    /**
     * Saves a possible game state generated by a turn.
     * Is needed to implement the game tree.
     */
    private BeanCell[] cells = new BeanCell[12];

    private int playerOnePoints;
    private int playerTwoPoints;
    private boolean currentPlayer = false;
    private boolean startPlayer = false; //true if this AI is the start player of the game

    public GameState(BeanCell[] gamestate, int playerOnePoints, int playerTwoPoints) {
        for (int i = 0; i < gamestate.length; i++) {
            cells[i] = new BeanCell(gamestate[i].getIndex(), gamestate[i].getBeans());
        }
        this.playerOnePoints = playerOnePoints;
        this.playerTwoPoints = playerTwoPoints;
    }

    /**
     * Changing the game state after the enemys move and builds the new game tree.
     *
     * @param cellIndex is the index of the chosen cell the enemy emptied
     */
    public void changeCurrentGamestate(int cellIndex) {
        int chosenIndex = --cellIndex;
        int numberOfBeans = cells[chosenIndex].getBeans();
        cells[chosenIndex].emptyCell();
        this.distributeBeansOverCurrentGameState(chosenIndex, numberOfBeans);
    }

    /**
     * Destributes all beans of the selected cell and collects all beans, which are collectable by the player.
     *
     * @param index index of the cell for the current turn
     * @param beansToDistribute number of beans inside the selected bean cell
     */
    private void distributeBeansOverCurrentGameState(int index, int beansToDistribute) {
        for (int i = 1; i <= beansToDistribute; i++) {
            cells[(index + i) % 12].increaseBeans();
        }
        if (cells[(index + beansToDistribute) % 12].getBeans() == 2
                || cells[(index + beansToDistribute) % 12].getBeans() == 4
                || cells[(index + beansToDistribute) % 12].getBeans() == 6) {
            while ((cells[(index + beansToDistribute) % 12].getBeans() == 2
                    || cells[(index + beansToDistribute) % 12].getBeans() == 4
                    || cells[(index + beansToDistribute) % 12].getBeans() == 6) && beansToDistribute > 0) {
                if (this.currentPlayer) {
                    this.playerOnePoints += cells[(index + beansToDistribute) % 12].collectBeans();
                } else {
                    this.playerTwoPoints += cells[(index + beansToDistribute) % 12].collectBeans();
                }
                beansToDistribute--;
            }
        }
    }

    public BeanCell[] getCells() {
        return cells;
    }

    /**
     * Calculates the heuristic by comparing ai points and enemy points.
     *
     * @return gamestate-heuristic
     */
    public int getHeuristic() {
        if (startPlayer) {
            return calculateHeuristic() + playerOnePoints - playerTwoPoints;
        } else {
            return calculateHeuristic() + playerTwoPoints - playerOnePoints;
        }
    }

    public void setStartPlayer(boolean startPlayer) {
        this.startPlayer = startPlayer;
    }

    /**
     * @return calculated heuristic for the game state
     */
    private int calculateHeuristic() {
        return 0;
    }

    /**
     * Counts the amount of possible turns for the player. Amount is calculated by counting all non-empty beancells.
     *
     * @return amount of possible turns
     */
    public int amountPossibleTurns() {
        int possibleTurns = 0;
        if (startPlayer) {
            for (int i = 0; i < 6; i++) {
                if (cells[i].getBeans() > 0) {
                    possibleTurns++;
                }
            }
        } else {
            for (int i = 6; i < 12; i++) {
                if (cells[i].getBeans() > 0) {
                    possibleTurns++;
                }
            }
        }
        return possibleTurns;
    }

    public int getPlayerOnePoints() {
        return playerOnePoints;
    }

    public int getPlayerTwoPoints() {
        return playerTwoPoints;
    }

    public boolean isCurrentPlayer() {
        return currentPlayer;
    }

    public void setCurrentPlayer(boolean currentPlayer) {
        this.currentPlayer = currentPlayer;
    }
}
